export class BadgeService {
    static async getStats(DB: D1Database, userId: string) {
        // 1. Get Player ID
        const player = await DB.prepare('SELECT id FROM players WHERE user_id = ?').bind(userId).first()
        if (!player) return null
        const playerId = player.id as number

        // 2. Aggregate Match Stats (Goals, Assists)
        const stats = await DB.prepare(`
            SELECT 
                SUM(goals) as total_goals, 
                SUM(assists) as total_assists
            FROM player_match_stats 
            WHERE player_id = ?
        `).bind(playerId).first<{ total_goals: number, total_assists: number }>()

        // 3. Attendance
        const attendance = await DB.prepare(`
            SELECT COUNT(*) as total FROM attendance WHERE player_id = ?
        `).bind(playerId).first<{ total: number }>()

        // 4. Wins and Podiums (Complex)
        // Need to calculate team ranks for every session this player participated in.
        // Simplified: Iterate sessions? Or complex Query?
        // Given D1 limit, maybe best to fetch all match results for sessions the player attended.
        
        // A. Get Session IDs participated
        const sessions = await DB.prepare('SELECT session_id FROM attendance WHERE player_id = ?').bind(playerId).all<{ session_id: number }>()
        
        let wins = 0
        let podiums = 0 // Top 3
        let streaks = 0 // Max Streak
        
        // B. Calculate Rank for each session (This logic is heavy, maybe optimization needed later)
        // For now, simple implementation
        if (sessions.results) {
            for (const s of sessions.results) {
                // Get Matches for session
                const matches = await DB.prepare('SELECT * FROM matches WHERE session_id = ?').bind(s.session_id).all()
                if (!matches.results || matches.results.length === 0) continue

                // Calculate Team Points
                const teamPoints: Record<number, number> = {}
                matches.results.forEach((m: any) => {
                    const s1 = m.team1_score || 0
                    const s2 = m.team2_score || 0
                    if (!teamPoints[m.team1_id]) teamPoints[m.team1_id] = 0
                    if (!teamPoints[m.team2_id]) teamPoints[m.team2_id] = 0

                    if (s1 > s2) teamPoints[m.team1_id] += 3
                    else if (s2 > s1) teamPoints[m.team2_id] += 3
                    else {
                        teamPoints[m.team1_id] += 1
                        teamPoints[m.team2_id] += 1
                    }
                })

                // Find Player's Team in this session
                const membership = await DB.prepare('SELECT team_id FROM team_members WHERE session_id = ? AND player_id = ?').bind(s.session_id, playerId).first()
                if (!membership) continue
                const myTeamId = membership.team_id as number
                
                // Rank Teams
                const sorted = Object.entries(teamPoints).sort(([,a], [,b]) => b - a)
                const myRank = sorted.findIndex(([tid]) => Number(tid) === myTeamId) + 1 // 1-based

                if (myRank === 1) wins++
                if (myRank <= 3) podiums++
            }
        }
        
        // Streak Calculation
        const dates = await DB.prepare(`
            SELECT s.session_date 
            FROM attendance a 
            JOIN sessions s ON a.session_id = s.id 
            WHERE a.player_id = ? 
            ORDER BY s.session_date ASC
        `).bind(playerId).all<{ session_date: string }>()
        
        if (dates.results) {
            let current = 0
            let maxStreak = 0
            // Simple approach: Check consecutive? But dates are sporadic.
            // Prompt says "Continuous Attendance" -> Consecutive Sessions hosted? 
            // Or Consecutive User's participation in available sessions?
            // Usually "Streak" means "Consecutive Participation in Held Sessions".
            // But checking "Held Sessions" requires fetching ALL sessions.
            // Let's assume Streak = Consecutive attendance in Hosted Sessions.
            
            // 1. Get ALL sessions sorted by date
            const allSessions = await DB.prepare('SELECT id, session_date FROM sessions ORDER BY session_date ASC').all<{ id: number }>()
            const attendedSet = new Set(dates.results.map(d => d.session_date)) // By date easier if unique
            
            // Actually use session IDs for accuracy
            const mySessionIds = new Set(sessions.results?.map(s => s.session_id))
            
            if (allSessions.results) {
                 for (const s of allSessions.results) {
                     if (mySessionIds.has(s.id)) {
                         current++
                     } else {
                         maxStreak = Math.max(maxStreak, current)
                         current = 0
                     }
                 }
                 maxStreak = Math.max(maxStreak, current)
                 streaks = maxStreak
            }
        }

        // Hattricks
         const hattricks = await DB.prepare(`
            SELECT COUNT(*) as count FROM player_match_stats WHERE player_id = ? AND goals >= 3
        `).bind(playerId).first<{ count: number }>()

        return {
            wins,
            podiums,
            goals: stats?.total_goals || 0,
            assists: stats?.total_assists || 0,
            attendance: attendance?.total || 0,
            streak: streaks,
            hattricks: hattricks?.count || 0
        }
    }

    static calculateScore(stats: any) {
        return (stats.wins * 10) + 
               ((stats.podiums - stats.wins) * 7) + // Wait, Podiums includes wins. 
               // Rule: 1st=10, 2nd=7, 3rd=5. 
               // My stats logic only has 'wins' (1st) and 'podiums' (1-3).
               // I can't distinguish 2nd/3rd easily with just 'podiums'.
               // I should refine logic to count 1st, 2nd, 3rd separately if possible.
               // Or approximate: If 3 teams, Podiums = all. But 1st is Win.
               // Let's refine getStats to return ranks map or separate counts.
               0 // Placeholder
    }
}
